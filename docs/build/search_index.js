var documenterSearchIndex = {"docs":
[{"location":"index.html#SimpleArgParse.jl-Documentation","page":"Home","title":"SimpleArgParse.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modules = [SimpleArgParse]\nOrder   = [:type, ]","category":"page"},{"location":"index.html#SimpleArgParse.AbstractValidator","page":"Home","title":"SimpleArgParse.AbstractValidator","text":"AbstractValidator\n\nThe supertype for validators. Type AbstractValidator is public, but not exported.\n\n\n\n\n\n","category":"type"},{"location":"index.html#SimpleArgParse.ArgForms","page":"Home","title":"SimpleArgParse.ArgForms","text":"ArgForms\n\nCommand-line arguments, short and long forms. Type ArgForms is exported.\n\nFields\n\nshort::String\nlong::String\n\n\n\n\n\n","category":"type"},{"location":"index.html#SimpleArgParse.ArgumentParser","page":"Home","title":"SimpleArgParse.ArgumentParser","text":"ArgumentParser\n\nCommand-line argument parser with numkey-value stores and attributes. Type ArgumentParser is exported.\n\nFields\n\nstores\n\nkv_store::OrderedDict{UInt16,ArgumentValues} = OrderedDict(): numkey => value \narg_store::OrderedDict{String,UInt16} = OrderedDict(): numkey-value store: arg => numkey\nlng::UInt16 = 0: counter of stored args\n\nattributes\n\nfilename::String = \"\": file name\ndescription::String = \"\": description\nauthors::Vector{String} = String[]: name of author(s): First Last <first.last@email.address>\ndocumentation::String = \"\": URL of documentations\nrepository::String = \"\": URL of software repository\nlicense::String = \"\": name of license\nusage::String = \"\": usage/help message\nexamples::Vector{String} = String[]: usage examples\nadd_help::Bool = false: flag to automatically generate a help message\ninteractive::Union{Nothing, InteractiveUsage} = nothing: interactive usage attributes (see InteractiveUsage)\n\n\n\n\n\n","category":"type"},{"location":"index.html#SimpleArgParse.ArgumentValues","page":"Home","title":"SimpleArgParse.ArgumentValues","text":"ArgumentValues\n\nCommand-line argument values. Type ArgumentValues is exported.\n\nFields\n\nconst args::ArgForms\nvalue::Any\nconst type::Type = Any\nconst positional::Bool = false\nconst description::String = \"\"\nconst validator::Union{AbstractValidator, Nothing} = nothing\n\n\n\n\n\n","category":"type"},{"location":"index.html#SimpleArgParse.InteractiveUsage","page":"Home","title":"SimpleArgParse.InteractiveUsage","text":"InteractiveUsage\n\nType InteractiveUsage is exported.\n\nFields\n\nthrow_on_exception = false: immediately throw on exception if true,    or process error downstream if false (interactive use)\ncolor::String = \"default\": output color (see colorize function)\nintroduction::String = \"\": explanation or introduction to be shown before prompt on a separate line\nprompt::String = \"> \"\n\n\n\n\n\n","category":"type"},{"location":"index.html#SimpleArgParse.RealValidator","page":"Home","title":"SimpleArgParse.RealValidator","text":"RealValidator{T} <: AbstractValidator\n\nNumbers validator type. If no include criteria specified, anything not excluded considered OK.  The intervals are evaluated as closed a ≤ x ≤ b. Type RealValidator is exported.\n\nFields\n\nexcl_vals::Vector{T} = T[]: list of values to exclude\nexcl_ivls::Vector{Tuple{T, T}} = Tuple{T, T}[]: list of intervals to exclude\nincl_vals::Vector{T} = T[]: list of accepted values\nincl_ivls::Vector{Tuple{T, T}} = Tuple{T, T}[]: list of accepted intervals\n\nExamples\n\njulia> validate(1, RealValidator{Int}(;excl_vals=[1, 2], excl_ivls=[(10, 15), (20, 25)], incl_vals=[3, 4, 11], incl_ivls=[(100, 1000)]))\n(ok = false, v = nothing)\n\njulia> validate(150, RealValidator{Int}(;incl_ivls=[(100, 200)]))\n(ok = true, v = 150)\n\njulia> validate(50, RealValidator{Int}(;excl_ivls=[(100, 200)]))\n(ok = true, v = 50)\n\n\n\n\n\n","category":"type"},{"location":"index.html#SimpleArgParse.StrValidator","page":"Home","title":"SimpleArgParse.StrValidator","text":"StrValidator <: AbstractValidator\n\nString validator type. Type StrValidator is exported.\n\nFields\n\nupper_case::Bool = false: If true, input and pattern converted to uppercase,    except for regex comparison\nstarts_with::Bool = false: If true, validate if one of the words in the patterns   starts with input. Returns the whole matching word.\npatterns::Vector{Union{AbstractString, Regex}}\n\nExamples\n\njulia> validate(\"foo\", StrValidator(; upper_case=true, patterns=[\"foo\", \"bar\"]))\n(ok = true, v = \"FOO\")\n\njulia> validate(\"foo\", StrValidator(; patterns=[r\"^fo[aoe]$\"]))\n(ok = true, v = \"foo\")\n\njulia> validate(\"ye\", StrValidator(; upper_case=true, starts_with=true, patterns=[\"yes\", \"no\"]))\n(ok = true, v = \"YES\")\n\n\n\n\n\n","category":"type"},{"location":"index.html#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"index.html#Exported-functions","page":"Home","title":"Exported functions","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"add_argument!\nadd_example!\nargs_pairs\ncolorprint\nhaskey\nhelp\nparse_args!\nshell_split\nvalidate","category":"page"},{"location":"index.html#SimpleArgParse.add_argument!","page":"Home","title":"SimpleArgParse.add_argument!","text":"add_argument!(parser::ArgumentParser, arg_short::String=\"\", arg_long::String=\"\"; kwargs...) → parser\n\nArguments\n\nparser::ArgumentParser: ArgumentParser object instance.\narg_short::String=\"\": short argument flag.\narg_long::String=\"\": long argument flag.\n\nKeywords\n\ntype::Type=nothing: type, the argument value to be parsed/converted into.\ndefault::Any=nothing\npositional::Bool=false\ndescription::String=nothing\nvalidator::Union{AbstractValidator, Nothing}=nothing \n\nFunction add_argument! is exported\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.add_example!","page":"Home","title":"SimpleArgParse.add_example!","text":"add_example!(parser::ArgumentParser, example::AbstractString) → parser\n\nFunction add_example! is exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.args_pairs","page":"Home","title":"SimpleArgParse.args_pairs","text":"args_pairs(parser::ArgumentParser; excl=[\"help\"]) → ::Vector{Pair{Symbol, Any}}\n\nReturn vector of pairs argname => argvalue for all arguments except listed in excl.     If argument has both short and long forms, the long one is used. Returned value can      be e.g. passed as kwargs... to a function processing the parsed data, converted to      a Dict or NamedTuple.\n\nFunction args_pairs is exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.colorprint","page":"Home","title":"SimpleArgParse.colorprint","text":"colorprint(text, color::AbstractString=\"default\", newline=true; background=false, bright=false) → nothing\ncolorprint(text, parser::ArgumentParser, newline=true; background=false, bright=false) → nothing\n\nPrint colored text into stdout. For color table, see help to internal colorize function.  If second arg is an ArgumentParser, uses color as defined within, if any, otherwise uses default.\n\nFunction colorprint is exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.haskey","page":"Home","title":"Base.haskey","text":"haskey(parser::ArgumentParser, key::AbstractString) → ::Bool\nhaskey(parser::ArgumentParser, key::Integer) → ::Bool\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.help","page":"Home","title":"SimpleArgParse.help","text":"help(parser::ArgumentParser; color::Union{AbstractString, Nothing}) → nothing\n\nPrint usage/help message. Function help is exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.parse_args!","page":"Home","title":"SimpleArgParse.parse_args!","text":"parse_args!(parser::ArgumentParser; cli_args=nothing) → ::Union{ArgumentParser, Exception}\n\nParses arguments, validates them and stores the updated values in the parser. \n\nKeywords\n\ncli_args::Union{Vector{AbstractString}, Nothing}=nothing: if the cli_args not provided,    parses the command line arguments ARGS. Otherwise accepts equivalent Vector of Strings,   e.g. [\"--foo\", \"FOO\", \"-i\", \"1\"]\n\nThrows\n\nException: depending on the value of parser.interactive, in case of non-valid    args vector, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction parse_args! is exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Base.shell_split","page":"Home","title":"Base.shell_split","text":"shell_split(s::AbstractString) → String[]\n\nSplit a string into a vector of args.\n\nshell_split is in internal function of Base. It is re-exported.\n\nExamples\n\njulia> shell_split(\"--foo 3 -b bar\")\n4-element Vector{String}:\n \"--foo\"\n \"3\"\n \"-b\"\n \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.validate","page":"Home","title":"SimpleArgParse.validate","text":"validate(v::Any, ::Nothing) → (;ok=true, v)\nvalidate(v::Nothing, ::Any) → (;ok=true, v)\nvalidate(v::Any, vl::AbstractValidator) → (;ok::Bool, v)\n\nValidate input v against validator vl, and returns named tuple with validation result ok  and (possibly canonicalized) input value v on success, or nothing on validation failure.  If nothing is supplied instead of Validator, validation skipped. The same, if the value v to be validated is nothing. For examples and specific information see documentation for the corresponding Validator, e.g. StrValidator or RealValidator. Function validate is exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Public-functions","page":"Home","title":"Public functions","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"SimpleArgParse.generate_usage!\nSimpleArgParse.get_value\nSimpleArgParse.getcolor\nSimpleArgParse.parse_arg\nSimpleArgParse.set_value!","category":"page"},{"location":"index.html#SimpleArgParse.generate_usage!","page":"Home","title":"SimpleArgParse.generate_usage!","text":"generate_usage!(parser::ArgumentParser) → ::String\n\nUsage/help message generator. Function generate_usage! is public, not exported.\n\nExample of generated text\n\nUsage: main.jl –input <PATH> [–verbose] [–problem] [–help]\n\nA Julia script with command-line arguments.\n\nOptions:   -i, –input <PATH>    Path to the input file.   -v, –verbose         Enable verbose message output.   -p, –problem         Print the problem statement.   -h, –help            Print this help message.\n\nExamples:   $ julia main.jl –input dir/file.txt –verbose   $ julia main.jl –help\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.get_value","page":"Home","title":"SimpleArgParse.get_value","text":"get_value(parser, arg) → value::Any\n\nGet argument value from parser. \n\nArguments\n\nparser::ArgumentParser: ArgumentParser object instance.\narg::AbstractString=\"\": argument name, e.g. \"-f\", \"--foo\".\n\nThrows\n\nException: depending on the value of throw_on_exception(parser), if the argument not    found, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction get_value is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.getcolor","page":"Home","title":"SimpleArgParse.getcolor","text":"getcolor(parser::ArgumentParser, color=nothing)  → color::String\n\nReturns color in case second arg is defined, otherwise the color defined in parser, or \"default\".\n\nFunction getcolor is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.parse_arg","page":"Home","title":"SimpleArgParse.parse_arg","text":"parse_arg(t::Type, val_str::Union{AbstractString, Bool}, ::Union{Nothing, AbstractValidator}) → (; ok, v=parsed_value, msg=nothing)\n\nTries to parse val_str to type t. For your custom types or custom parsing, provide your own methods.\n\nFunction parse_arg is public, but not exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#SimpleArgParse.set_value!","page":"Home","title":"SimpleArgParse.set_value!","text":"set_value!(parser::ArgumentParser, numkey::Integer, value::Any) → parser\nset_value!(parser::ArgumentParser, argname::AbstractString, value::Any) → parser\n\nSet/update value of argument, validating it, as specified by numkey or argname, in parser.\n\nThrows\n\nException: depending on the value of throw_on_exception , if the argument not    found, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction set_value! is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Internal-functions","page":"Home","title":"Internal functions","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modules = [SimpleArgParse]\nOrder   = [:function]\nFilter = t -> !any(occursin.([\"add_argument!\",\n    \"add_example!\",\n    \"args_pairs\",\n    \"colorprint\",\n    \"haskey\",\n    \"help\",\n    \"parse_args!\",\n    \"shell_split\",\n    \"validate\",\n    \"generate_usage!\",\n    \"get_value\",\n    \"getcolor\",\n    \"parse_arg\",\n    \"set_value!\",], Ref(string(nameof(t)))))","category":"page"},{"location":"index.html#SimpleArgParse._error-Tuple{Any, Any}","page":"Home","title":"SimpleArgParse._error","text":"_error(throw_on_exception, msg::AbstractString; excp=ArgumentError) → ::Exception\n\nDepending on value of throw_on_exception, throw immediately, or return Exception to be  processed downstream.\n\nFunction _error is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.arg2strkey-Tuple{Any}","page":"Home","title":"SimpleArgParse.arg2strkey","text":"arg2strkey(arg::AbstractString) → ::SubString\n\nArgument to argument-store string key conversion by removing hypenation from prefix.\n\nFunction arg2strkey is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.args2vec-Tuple{ArgForms}","page":"Home","title":"SimpleArgParse.args2vec","text":"args2vec(args::ArgForms) → ::Vector{String}\n\nExtract struct members to vector of length 1 or 2.\n\nFunction args2vec is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.argument_usage-Tuple{Any}","page":"Home","title":"SimpleArgParse.argument_usage","text":"argument_usage(v::ArgumentValues) → (; u=args_usage, o=options)\n\nFunction argument_usage is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.colorize-Tuple{AbstractString}","page":"Home","title":"SimpleArgParse.colorize","text":"colorize(text; color, background, bright) → ::String\n\nColorize strings or backgrounds using ANSI codes and escape sequences.\n\nColor Example Text Background Bright text Bright background\nBlack Black 30 40 90 100\nRed Red 31 41 91 101\nGreen Green 32 42 92 102\nYellow Yellow 33 43 93 103\nBlue Blue 34 44 94 104\nMagenta Magenta 35 45 95 105\nCyan Cyan 36 46 96 106\nWhite White 37 47 97 107\nDefault  39 49 99 109\n\nArguments\n\ntext::AbstractString: the UTF-8/ASCII text to colorize.\n\nKeywords\n\ncolor::AbstractString=\"default\": the standard ANSI name of the color.\nbackground::Bool=false: flag to select foreground or background color.\nbright::Bool=false: flag to select normal or bright text.\n\nFunction colorize is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.hyphenate-Tuple{AbstractString}","page":"Home","title":"SimpleArgParse.hyphenate","text":"hyphenate(argname::AbstractString) → ::String\n\nPrepend hyphenation back onto argument after stripping it for the argument-store numkey.\n\nFunction hyphenate is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.sort_args-Tuple{Any}","page":"Home","title":"SimpleArgParse.sort_args","text":"sort_args(parser::ArgumentParser) → (;pos_args, keyed_args, all_args)\n\nFunction sort_args is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#SimpleArgParse.update_val!-Tuple{Any, Any, Any}","page":"Home","title":"SimpleArgParse.update_val!","text":"update_val!(parser::ArgumentParser, numkey::Integer, val_str::AbstractString) → parser\n\nSee also set_value!. Function update_val! is internal.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Constants","page":"Home","title":"Constants","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modules = [SimpleArgParse]\nOrder   = [:constant, ]","category":"page"},{"location":"index.html#SimpleArgParse.ANSICODES","page":"Home","title":"SimpleArgParse.ANSICODES","text":"Key-value store mapping from colors to ANSI codes. An internal constant.\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"}]
}
