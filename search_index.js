var documenterSearchIndex = {"docs":
[{"location":"usage/#Installation","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"As usual, e.g.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"] add YAArguParser","category":"page"},{"location":"usage/#Specification","page":"Usage","title":"Specification","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"We approximate the Microsoft command-line syntax. Optional arguments are surrounded by square brackets, values are surrounded by angle brackets (chevrons), and mutually exclusive items are separated by a vertical bar. ","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Apart from these usage examples (you find the complete sources in the./examples folder), we suggest you also check the the testsuite ./test/runtests.jl .","category":"page"},{"location":"usage/#Example-1-common-usage","page":"Usage","title":"Example 1 - common usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"We first create an ArgumentParser object, then add and parse our command-line arguments. We will automagically generate a usage string from our key-value store of command-line arguments here, but is also possible to write your own help message instead. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using YAArguParser: ArgumentParser, add_argument!, add_example!, help, parse_args!, args_pairs, generate_usage!\n\nfunction main()\n\n    ap = ArgumentParser(description=\"YAArguParser example.\", add_help=true)\n    add_argument!(ap, \"-h\", \"--help\", type=Bool, default=false, description=\"Help switch.\")\n    add_argument!(ap, \"-i\", \"--input\", type=String, default=\"filename.txt\", description=\"Input file.\")\n    add_argument!(ap, \"-n\", \"--number\", type=Int, default=0, description=\"Integer number.\")\n    add_argument!(ap, \"-v\", \"--verbose\", type=Bool, default=false, description=\"Verbose mode switch.\")\n    add_example!(ap, \"julia $(ap.filename) --input dir/file.txt --number 10 --verbose\")\n    add_example!(ap, \"julia $(ap.filename) --help\")\n\n    parse_args!(ap)\n\n    # get all arguments as NamedTuple\n    args = NamedTuple(args_pairs(ap))\n\n    # print the usage/help message in magenta if asked for help\n    args.help && help(ap, color=\"magenta\")\n\n    # display the arguments\n    println(args)\n\n    # DO SOMETHING ELSE\n\n    return 0\nend\n\nmain()","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"That is about as simple as it gets and closely follows Python's argparse. ","category":"page"},{"location":"usage/#Example-2-customized-help","page":"Usage","title":"Example 2 - customized help","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let's define a customized help message:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using YAArguParser\n\nconst usage = raw\"\"\"\n  Usage: main.jl --input <PATH> [--verbose] [--problem] [--help]\n\n  A Julia script with command-line arguments.\n\n  Options:\n    -i, --input <PATH>    Path to the input file.\n    -v, --verbose         Enable verbose message output.\n    -p, --problem         Print the problem statement.\n    -h, --help            Print this help message.\n\n  Examples:\n    $ julia main.jl --input dir/file.txt --verbose\n    $ julia main.jl --help\n\"\"\"\n\nfunction main()\n\n    ap = ArgumentParser(description=\"YAArguParser example.\", add_help=true, color=\"cyan\")\n    add_argument!(ap, \"-h\", \"--help\", type=Bool, default=false, description=\"Help switch.\")\n    add_argument!(ap, \"-i\", \"--input\", type=String, default=\"filename.txt\", description=\"Input file.\")\n    add_argument!(ap, \"-n\", \"--number\", type=Int, default=0, description=\"Integer number.\")\n    add_argument!(ap, \"-v\", \"--verbose\", type=Bool, default=false, description=\"Verbose mode switch.\")\n    add_example!(ap, \"julia $(ap.filename) --input dir/file.txt --number 10 --verbose\")\n    add_example!(ap, \"julia $(ap.filename) --help\")\n\n    # add usage/help text from above\n    ap.usage = usage\n\n    parse_args!(ap)\n\n    # print the usage/help message in color defined in ap\n    help(ap)\n\n    # DO SOMETHING ELSE\n\n    return 0\nend\n\nmain()","category":"page"},{"location":"usage/#Example-3-validating-arguments","page":"Usage","title":"Example 3 - validating arguments","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"For Validator details, read Docstrings sections for RealValidator, StrValidator and validate.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using YAArguParser\nusing YAArguParser: shell_split\n\nfunction main()\n\n    ap = ArgumentParser(; \n        description=\"Command line options parser\", \n        add_help=true, \n        color = \"cyan\", \n        )\n\n    add_argument!(ap, \"-p\", \"--plotformat\"; \n        type=String, \n        default=\"PNG\",\n        description=\"Accepted file format: PNG (default), PDF, SVG or NONE\", \n        validator=StrValidator(; upper_case=true, patterns=[\"PNG\", \"SVG\", \"PDF\", \"NONE\"]),\n        )\n\n    add_argument!(ap, \"-n\", \"--number\"; \n        type=Int, \n        # an argument with a default value is optional, without - required \n        # default=nothing,\n        description=\"an integer value ranging from 0 to 42\", \n        validator=RealValidator{Int}(; incl_ivls=[(0, 42)]),\n        )\n    \n    add_example!(ap, \"$(ap.filename) -n 1 --plotformat NONE\")\n    add_example!(ap, \"$(ap.filename) -n 1\")\n    add_example!(ap, \"$(ap.filename) --help\")\n\n    # simulate supplied args\n    str = \"-p SVG -n 33 --help\"\n    args = shell_split(str)\n\n    parse_args!(ap; cli_args=args)\n\n    # get all arguments as NamedTuple\n    args = NamedTuple(args_pairs(ap))\n\n    # print the usage/help message in color defined during initialization, if asked for help\n    args.help && help(ap)\n\n    # display the arguments\n    println(args)\n\n    # DO SOMETHING with args\n\n    return ap\nend\n\nmain()","category":"page"},{"location":"usage/#Example-4-custom-parser,-initparser","page":"Usage","title":"Example 4 - custom parser, initparser","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This example shows how to create a customized parser. Here, we create LegacyArgumentParser type which is equivalent to ArgumentParser  of SimpleArgParse. You see that by making our type a subtype of  AbstractArgumentParser we achieve a flattened access to the struct properties. This is used by initparser function, which simplifies initilalization of nested structs.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using YAArguParser\nusing YAArguParser: AbstractArgumentParser\n\n@kwdef mutable struct LegacyArgumentParser <: AbstractArgumentParser\n    ap::ArgumentParser = ArgumentParser()\n    authors::Vector{String} = String[]\n    documentation::String = \"\"\n    repository::String = \"\"\n    license::String = \"\"\nend\n\nlp = initparser(LegacyArgumentParser; license=\"MIT\", authors=[\"Eben60\"], description=\"Example how to extend an argument parser\")\n@assert lp.ap.description == lp.description","category":"page"},{"location":"usage/#Example-5-positional-arguments,-custom-validator,-initparser","page":"Usage","title":"Example 5 - positional arguments, custom validator, initparser","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"using Dates\nusing YAArguParser\nusing YAArguParser: AbstractValidator, warn_and_return\nimport YAArguParser: validate\n\n@kwdef struct FullAgeValidator <: AbstractValidator\n    legal_age::Int = 18\nend\n\nfunction validate(v::Union{AbstractString, Date}, vl::FullAgeValidator)\n    birthdate = today()\n    try\n        birthdate = Date(v)\n    catch\n        return warn_and_return(v)\n    end\n\n    d = day(birthdate)\n    m = month(birthdate)\n    fullageyear = year(birthdate) + vl.legal_age\n\n    Date(fullageyear, m, d) > today() && return warn_and_return(v)\n\n    return (; ok=true, v=birthdate)\nend\n\nfunction askandget(pp; color=pp.color)\n    colorprint(pp.introduction, color)\n    colorprint(pp.prompt, color, false; bold=true)\n    answer = readline()\n    cli_args = Base.shell_split(answer)\n    parse_args!(pp; cli_args)\n    r = NamedTuple(args_pairs(pp))\n    if r.help\n        help(pp)\n        exit()\n    end\n    r.abort && exit()\n    return r\nend\n\nfunction main()\n\n    color = \"cyan\"\n    prompt = \"legal age check> \"\n\n    ask_full_age = let\n        pp = initparser(InteractiveArgumentParser;  \n            description=\"Asking if one is of full age\", \n            add_help=true, \n            color = color,\n            introduction=\"Are you of full legal age? Please type y[es] or n[o] and press <ENTER>\",\n            throw_on_exception = true,\n            prompt=prompt,\n            )\n\n        add_argument!(pp, \"-y\", \"--yes_no\"; \n            type=String, \n            positional=true,\n            description=\"Asking about legal age\",\n            validator=StrValidator(; upper_case=true, starts_with=true, patterns=[\"yes\", \"no\"]),\n            )\n    \n        add_argument!(pp, \"-a\", \"--abort\", \n            type=Bool, \n            default=false,\n            description=\"Abort?\",\n            )   \n        \n        add_example!(pp, \"$(pp.prompt) y\")\n        add_example!(pp, \"$(pp.prompt) --abort\")\n        add_example!(pp, \"$(pp.prompt) --help\")\n        pp\n    end\n\n    check_full_age = let\n        pp = initparser(InteractiveArgumentParser; \n            description=\"Checking if one is of full age\", \n            add_help=true, \n            color=color, \n            throw_on_exception = true,\n            introduction=\"Please enter your birth date in the yyyy-mm-dd format\",\n            prompt=prompt,\n            )\n\n        add_argument!(pp, \"-d\", \"--birthdate\"; \n            type=Date, \n            positional=true,\n            description=\"Asking about legal age\",\n            validator=FullAgeValidator(),\n            )\n    \n        add_argument!(pp, \"-a\", \"--abort\", \n            type=Bool, \n            default=false, \n            description=\"Abort?\",\n            )   \n        \n        add_example!(pp, \"$(pp.prompt) 2000-02-29\")\n        add_example!(pp, \"$(pp.prompt) --abort\")\n        add_example!(pp, \"$(pp.prompt) --help\")\n        pp\n    end\n\n    (; yes_no ) = askandget(ask_full_age)\n    yes = (yes_no == \"YES\")\n    yes || return false\n\n    (; birthdate) = askandget(check_full_age )\n    println(\"You appear to be of full age.\")\n\n    return true\nend\n\nmain()","category":"page"},{"location":"finally/#New-Features-and-Changelog","page":"Changelog, Related packages, License","title":"New Features and Changelog","text":"","category":"section"},{"location":"finally/#Release-1.1.2","page":"Changelog, Related packages, License","title":"Release 1.1.2","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"05.12.2024","category":"page"},{"location":"finally/#Changes","page":"Changelog, Related packages, License","title":"Changes","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Added package docstring.","category":"page"},{"location":"finally/#Release-1.1.1","page":"Changelog, Related packages, License","title":"Release 1.1.1","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"04.12.2024","category":"page"},{"location":"finally/#Fixes","page":"Changelog, Related packages, License","title":"Fixes","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Now correctly accepts negative values for numerical arguments.","category":"page"},{"location":"finally/#Release-1.1.0","page":"Changelog, Related packages, License","title":"Release 1.1.0","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"28.07.2024","category":"page"},{"location":"finally/#New-features","page":"Changelog, Related packages, License","title":"New features","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Function colorprint now supports keywords bold, italic,    underline and blink, and accepts both String and Symbol as its color arg.","category":"page"},{"location":"finally/#Release-1.0.0-changes-as-compared-to-[SimpleArgParse](https://github.com/admercs/SimpleArgParse.jl)","page":"Changelog, Related packages, License","title":"Release 1.0.0 - changes as compared to SimpleArgParse","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"13.07.2024","category":"page"},{"location":"finally/#Breaking-changes","page":"Changelog, Related packages, License","title":"Breaking changes","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Renamed exported/public mutating functions, e.g. add_example => add_example!.\nMutating functions do not return ArgumentParser anymore: They return either nothing, or an Exception.\nLimited the number of exported functions.\nHashmap keys no more used, therefore get_key function removed.\nRemoved has_key function - use haskey instead.\nRemoved required field of ArgumentParser: If a default value provided, then argument is obviously optional, otherwise considered required.\nRemoved authors, documentation, repository, and license fields of ArgumentParser:    Should you need them, see Example 4 and the file legacy_parser.jl.\nMinimal Julia version set to v1.9.\nAnything forgotten?..","category":"page"},{"location":"finally/#New-features-2","page":"Changelog, Related packages, License","title":"New features","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Support for (extensible) validators (example).\nSupport for extensible parsers (example).\nSupport for positional arguments (example).\nSupport for use from console apps (example).\nThe added function initparser simplifies initilalization of nested structs.\nThe added function args_pairs makes it possible get all arguments at once as pairs [argname => argvalue].\nDepending on value of throw_on_exception field, functions processing the input would either throw on erroneous input, or return an Exception object for a less disruptive processing downstream.\nAnything forgotten?..","category":"page"},{"location":"finally/#Other-changes","page":"Changelog, Related packages, License","title":"Other changes","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Precompile package using PrecompileTools.jl to improve startup time.\nGeneral code refactoring.\nMade use of public keyword introduced in the coming Julia v1.11.\nTest suite extended and now includes Aqua.jl testing, too.\nExtensive Documenter.jl-based documentation you are reading now.\nExamples added.","category":"page"},{"location":"finally/#Related-packages","page":"Changelog, Related packages, License","title":"Related packages","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"As already mentioned, this package is a fork of SimpleArgParse.\nThe popular ArgParse offers much of the same functionality and more.\nComonicon, a CLI (Command Line Interface) generator.\nFire is a library for creating simple CLI from julia function definitions.\nmce (Maurice) CLI - The Julia Language project manager,   with useful functionality for beginners and advanced programmers ... currently in the 'Alpha' phase.\nThe package GivEmExel relies heavily onto YAArguParser and has been the stimulus for it's development.","category":"page"},{"location":"finally/#Likes-and-dislikes?","page":"Changelog, Related packages, License","title":"Likes & dislikes?","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Star on GitHub, open an issue, contact me on Julia Discourse.","category":"page"},{"location":"finally/#Copyright-and-License","page":"Changelog, Related packages, License","title":"Copyright and License","text":"","category":"section"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"© 2024 Eben60","category":"page"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"Portions of this software are based in part on the work by Adam Erickson ","category":"page"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"© 2024 Adam Erickson ","category":"page"},{"location":"finally/","page":"Changelog, Related packages, License","title":"Changelog, Related packages, License","text":"MIT License (see separate file LICENSE)","category":"page"},{"location":"","page":"Preface","title":"Preface","text":"(Image: License: MIT) (Image: Lifecycle) (Image: Documentation)  (Image: Build Status)  (Image: Coverage)  (Image: Aqua QA)","category":"page"},{"location":"#Preface","page":"Preface","title":"Preface","text":"","category":"section"},{"location":"","page":"Preface","title":"Preface","text":"This package is a fork of SimpleArgParse, which in turn is a minimalistic command-line argument parsing library in the spirit of Python's argparse. ","category":"page"},{"location":"","page":"Preface","title":"Preface","text":"In comparison with SimpleArgParse, the code has been substantially refactored, the parser made extensible, and interactive use in console applications and an extensible input validator has been added. See New Features and Changelog for details.","category":"page"},{"location":"docstrings/#Types","page":"Docstrings","title":"Types","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [YAArguParser]\nOrder   = [:type, ]","category":"page"},{"location":"docstrings/#YAArguParser.AbstractArgumentParser","page":"Docstrings","title":"YAArguParser.AbstractArgumentParser","text":"abstract type AbstractArgumentParser\n\nThe supertype for argument parser types. Base functions hasproperty, getproperty, setproperty!, and propertynames have overloaded methods for AbstractArgumentParser, providing a flattened view onto nested structs. See also initparser.\n\nType AbstractArgumentParser  is public, but not exported.\n\nExamples\n\njulia> @kwdef mutable struct MyAP <: AbstractArgumentParser\n       ap::ArgumentParser=ArgumentParser()\n       foo::Bool=false\n       end\nMyAP\n\njulia> x = MyAP(ap=ArgumentParser(; color=\"magenta\"); foo=true);\n\njulia> x.foo\ntrue\n\njulia> x.ap.color\n\"magenta\"\n\njulia> x.color\n\"magenta\"\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.AbstractValidator","page":"Docstrings","title":"YAArguParser.AbstractValidator","text":"AbstractValidator\n\nThe supertype for validators. Type AbstractValidator is public, but not exported.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.ArgForms","page":"Docstrings","title":"YAArguParser.ArgForms","text":"ArgForms\n\nCommand-line arguments, short and long forms. \n\nFields\n\nshort::String\nlong::String\n\nType ArgForms is exported.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.ArgumentParser","page":"Docstrings","title":"YAArguParser.ArgumentParser","text":"ArgumentParser <: AbstractArgumentParser\n\nCommand-line argument parser with numkey-value stores and attributes. \n\nFields\n\nstores\n\nkv_store::OrderedDict{UInt16,ArgumentValues} = OrderedDict(): numkey => value \narg_store::OrderedDict{String,UInt16} = OrderedDict(): numkey-value store: arg => numkey\nlng::UInt16 = 0: counter of stored args\n\nattributes\n\ndescription::String = \"\": description\nusage::String = \"\": The script name passed to Julia from the command line.\nusage::String = \"\": usage/help message\nexamples::Vector{String} = String[]: usage examples\nadd_help::Bool = false: flag to automatically generate a help message\ncolor::String = \"default\": output color - for color table, see help to colorprint function.\n\nType ArgumentParser is exported\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.ArgumentValues","page":"Docstrings","title":"YAArguParser.ArgumentValues","text":"ArgumentValues\n\nCommand-line argument values. \n\nFields\n\nconst args::ArgForms\nvalue::Any\nconst type::Type = Any\nconst positional::Bool = false\nconst description::String = \"\"\nconst validator::Union{AbstractValidator, Nothing} = nothing\n\nType ArgumentValues is exported.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.InteractiveArgumentParser","page":"Docstrings","title":"YAArguParser.InteractiveArgumentParser","text":"InteractiveArgumentParser <: AbstractArgumentParser\n\nExtension of ArgumentParser for interactive use. \n\nFields\n\nap::ArgumentParser = ArgumentParser()\nthrow_on_exception = false: cause to immediately throw on exception if true,    vs. processing error downstream if false (interactive use)\nintroduction::String = \"\": explanation or introduction to be shown before prompt on a separate line\nprompt::String = \"> \"\n\nType InteractiveArgumentParser is exported.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.RealValidator","page":"Docstrings","title":"YAArguParser.RealValidator","text":"RealValidator{T} <: AbstractValidator\n\nNumbers validator type. If no include criteria specified, anything not excluded considered OK.  The intervals are evaluated as closed a ≤ x ≤ b.\n\nFields\n\nexcl_vals::Vector{T} = T[]: list of values to exclude\nexcl_ivls::Vector{Tuple{T, T}} = Tuple{T, T}[]: list of intervals to exclude\nincl_vals::Vector{T} = T[]: list of accepted values\nincl_ivls::Vector{Tuple{T, T}} = Tuple{T, T}[]: list of accepted intervals\n\nType RealValidator is exported.\n\nExamples\n\njulia> validate(1, RealValidator{Int}(;excl_vals=[1, 2], excl_ivls=[(10, 15), (20, 25)], incl_vals=[3, 4, 11], incl_ivls=[(100, 1000)]))\n(ok = false, v = nothing)\n\njulia> validate(150, RealValidator{Int}(;incl_ivls=[(100, 200)]))\n(ok = true, v = 150)\n\njulia> validate(50, RealValidator{Int}(;excl_ivls=[(100, 200)]))\n(ok = true, v = 50)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#YAArguParser.StrValidator","page":"Docstrings","title":"YAArguParser.StrValidator","text":"StrValidator <: AbstractValidator\n\nString validator type. \n\nFields\n\nupper_case::Bool = false: If true, input and pattern converted to uppercase,    except for regex comparison\nstarts_with::Bool = false: If true, validate if one of the words in the patterns   starts with input. Returns the whole matching word.\npatterns::Vector{Union{AbstractString, Regex}}\n\nType StrValidator is exported.\n\nExamples\n\njulia> validate(\"foo\", StrValidator(; upper_case=true, patterns=[\"foo\", \"bar\"]))\n(ok = true, v = \"FOO\")\n\njulia> validate(\"foo\", StrValidator(; patterns=[r\"^fo[aoe]$\"]))\n(ok = true, v = \"foo\")\n\njulia> validate(\"ye\", StrValidator(; upper_case=true, starts_with=true, patterns=[\"yes\", \"no\"]))\n(ok = true, v = \"YES\")\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Functions","page":"Docstrings","title":"Functions","text":"","category":"section"},{"location":"docstrings/#Exported-functions","page":"Docstrings","title":"Exported functions","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"add_argument!\nadd_example!\nargs_pairs\ncolorprint\nhaskey\nhelp\nparse_args!","category":"page"},{"location":"docstrings/#YAArguParser.add_argument!","page":"Docstrings","title":"YAArguParser.add_argument!","text":"add_argument!(parser::AbstractArgumentParser, arg_short::String=\"\", arg_long::String=\"\"; kwargs...) → Nothing\n\nArguments\n\nparser::AbstractArgumentParser: AbstractArgumentParser object instance.\narg_short::String=\"\": short argument flag.\narg_long::String=\"\": long argument flag.\n\nKeywords\n\ntype::Type=nothing: type, the argument value to be parsed/converted into.\ndefault::Any=nothing\npositional::Bool=false\ndescription::String=nothing\nvalidator::Union{AbstractValidator, Nothing}=nothing \n\nThrows\n\nThrows immediately in case of error, e.g. if a key already present.\n\nFunction add_argument! is exported\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.add_example!","page":"Docstrings","title":"YAArguParser.add_example!","text":"add_example!(parser::AbstractArgumentParser, example::AbstractString) → Nothing\n\nFunction add_example! is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.args_pairs","page":"Docstrings","title":"YAArguParser.args_pairs","text":"args_pairs(parser::AbstractArgumentParser; excl::Union{Nothing, Vector{String}}=nothing) → ::Vector{Pair{Symbol, Any}}\n\nReturn vector of pairs argname => argvalue for all arguments except listed in excl.     If argument has both short and long forms, the long one is used. Returned value can      be e.g. passed as kwargs... to a function processing the parsed data, converted to      a Dict or NamedTuple.\n\nFunction args_pairs is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.colorprint","page":"Docstrings","title":"YAArguParser.colorprint","text":"colorprint(text, color::Union{AbstractString, Symbol}=\"default\", newline=true; background=false, \n    bright=false, bold=false, italic=false, underline=false, blink=false) → nothing\ncolorprint(text, parser::AbstractArgumentParser, newline=true; kwargs...) → nothing\n\nPrint colored/styled text into stdout, provided the terminal supports it. Available colors are  \"black\", \"red\", \"green\", \"yellow\", \"blue\", \"magenta\", \"cyan\", \"white\", and \"default\". If second arg is an AbstractArgumentParser, uses color as defined within, if any, otherwise uses \"default\".\n\nFunction colorprint is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.haskey","page":"Docstrings","title":"Base.haskey","text":"haskey(parser::AbstractArgumentParser, key::AbstractString) → \nhaskey(parser::AbstractArgumentParser, key::Integer) →\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.help","page":"Docstrings","title":"YAArguParser.help","text":"help(parser::AbstractArgumentParser; color::Union{AbstractString, Nothing}) → nothing\n\nPrint usage/help message. Function help is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.parse_args!","page":"Docstrings","title":"YAArguParser.parse_args!","text":"parse_args!(parser::AbstractArgumentParser; cli_args=nothing) →  ::Union{Nothing, Exception}\n\nParses arguments, validates them and stores the updated values in the parser. \n\nKeywords\n\ncli_args::Union{Vector{AbstractString}, Nothing}=nothing: if the cli_args not provided,    parses the command line arguments ARGS. Otherwise accepts equivalent Vector of Strings,   e.g. [\"--foo\", \"FOO\", \"-i\", \"1\"]\n\nThrows\n\nException: depending on the value of parser.interactive, in case of non-valid    args vector, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction parse_args! is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Public-functions","page":"Docstrings","title":"Public functions","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"YAArguParser.generate_usage!\nYAArguParser.get_value\nYAArguParser.getcolor\nYAArguParser.parse_arg\nYAArguParser.set_value!\nYAArguParser.shell_split\nYAArguParser.validate","category":"page"},{"location":"docstrings/#YAArguParser.generate_usage!","page":"Docstrings","title":"YAArguParser.generate_usage!","text":"generate_usage!(parser::AbstractArgumentParser) → Nothing\n\nUsage/help message generator. Function generate_usage! is public, not exported.\n\nExample of generated text\n\nUsage: main.jl –input <PATH> [–verbose] [–problem] [–help]\n\nA Julia script with command-line arguments.\n\nOptions:   -i, –input <PATH>    Path to the input file.   -v, –verbose         Enable verbose message output.   -p, –problem         Print the problem statement.   -h, –help            Print this help message.\n\nExamples:   $ julia main.jl –input dir/file.txt –verbose   $ julia main.jl –help\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.get_value","page":"Docstrings","title":"YAArguParser.get_value","text":"get_value(parser, arg) → value::Any\n\nGet argument value from parser. \n\nArguments\n\nparser::AbstractArgumentParser: AbstractArgumentParser object instance.\narg::AbstractString=\"\": argument name, e.g. \"-f\", \"--foo\".\n\nThrows\n\nException: depending on the value of throw_on_exception(parser), if the argument not    found, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction get_value is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.getcolor","page":"Docstrings","title":"YAArguParser.getcolor","text":"getcolor(parser::AbstractArgumentParser, color=nothing)  → color::String\n\nReturns color in case second arg is defined, otherwise the color defined in parser, or \"default\".\n\nFunction getcolor is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.parse_arg","page":"Docstrings","title":"YAArguParser.parse_arg","text":"parse_arg(t::Type, val_str::Union{AbstractString, Bool}, ::Union{Nothing, AbstractValidator}) → (; ok, v=parsed_value, msg=nothing)\n\nTries to parse val_str to type t. For your custom types or custom parsing, provide your own methods.\n\nFunction parse_arg is public, but not exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.set_value!","page":"Docstrings","title":"YAArguParser.set_value!","text":"set_value!(parser::AbstractArgumentParser, numkey::Integer, value::Any) → ::Union{Nothing, Exception}\nset_value!(parser::AbstractArgumentParser, argname::AbstractString, value::Any) → ::Union{Nothing, Exception}\n\nSet/update value of argument, validating it, as specified by numkey or argname, in parser.\n\nThrows\n\nException: depending on the value of throw_on_exception , if the argument not    found, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction set_value! is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.shell_split","page":"Docstrings","title":"Base.shell_split","text":"shell_split(s::AbstractString) → String[]\n\nSplit a string into a vector of args.\n\nshell_split is in internal function of Base, accessible as a public function of YAArguParser e.g.  by using YAArguParser: shell_split.\n\nExamples\n\njulia> shell_split(\"--foo 3 -b bar\")\n4-element Vector{String}:\n \"--foo\"\n \"3\"\n \"-b\"\n \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.validate","page":"Docstrings","title":"YAArguParser.validate","text":"validate(v::Any, ::Nothing) → (;ok=true, v)\nvalidate(v::Missing, ::Any) → (;ok=true, v)\nvalidate(v::Any, vl::AbstractValidator) → (;ok::Bool, v)\n\nValidate input v against validator vl, and returns named tuple with validation result ok  and (possibly canonicalized) input value v on success, or nothing on validation failure.  If nothing is supplied instead of Validator, validation skipped. The same, if the value v to be validated is nothing. For examples and specific information see documentation for the corresponding Validator, e.g. StrValidator or RealValidator. \n\nFunction validate is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Internal-functions","page":"Docstrings","title":"Internal functions","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [YAArguParser]\nOrder   = [:function]\nFilter = t -> !any(occursin.([\"add_argument!\",\n    \"add_example!\",\n    \"args_pairs\",\n    \"colorprint\",\n    \"haskey\",\n    \"help\",\n    \"parse_args!\",\n    \"shell_split\",\n    \"validate\",\n    \"generate_usage!\",\n    \"get_value\",\n    \"getcolor\",\n    \"parse_arg\",\n    \"set_value!\",], Ref(string(nameof(t)))))","category":"page"},{"location":"docstrings/#YAArguParser._error-Tuple{Any, Any}","page":"Docstrings","title":"YAArguParser._error","text":"_error(throw_on_exception, msg::AbstractString; excp=ArgumentError) → ::Exception\n\nDepending on value of throw_on_exception, throw immediately, or return Exception to be  processed downstream.\n\nFunction _error is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.arg2strkey-Tuple{Any}","page":"Docstrings","title":"YAArguParser.arg2strkey","text":"arg2strkey(arg::AbstractString) → ::SubString\n\nArgument to argument-store string key conversion by removing hypenation from prefix.\n\nFunction arg2strkey is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.args2vec-Tuple{ArgForms}","page":"Docstrings","title":"YAArguParser.args2vec","text":"args2vec(args::ArgForms) → ::Vector{String}\n\nExtract struct members to vector of length 1 or 2.\n\nFunction args2vec is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.argument_usage-Tuple{Any}","page":"Docstrings","title":"YAArguParser.argument_usage","text":"argument_usage(v::ArgumentValues) → (; u=args_usage, o=options)\n\nFunction argument_usage is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.check_missing_input-Tuple{Any}","page":"Docstrings","title":"YAArguParser.check_missing_input","text":"check_missing_input(parser::AbstractArgumentParser) → Union{Nothing, Exception}\n\nChecks if all required arguments were supplied. Required is an argument without a default value.  \n\nThrows\n\nException: depending on the value of throw_on_exception(parser), if an argument is    missing, the function will either throw imediately, or return e <: Exception to be    processed downstream.\n\nFunction check_missing_input is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.hyphenate-Tuple{AbstractString}","page":"Docstrings","title":"YAArguParser.hyphenate","text":"hyphenate(argname::AbstractString) → ::String\n\nPrepend hyphenation back onto argument after stripping it for the argument-store numkey.\n\nFunction hyphenate is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.initparser","page":"Docstrings","title":"YAArguParser.initparser","text":"initparser(AP::::Type{AbstractArgumentParser}, strict=true; kwargs...) →  ::AbstractArgumentParser\n\nInitializes a parser. First a parser of AP type with default values is created, then it's properties set  to the values provided by kwargs. With strict flag set, checks if every kwarg  corresponds to an AP property, otherwise ignore those without correspondence.\n\ninitparser is a syntactic sugar to \"normal\" struct initialization, making use of the flattened view onto  nested structs , as provided by overloading of property functions for AbstractArgumentParser.\n\nThrows\n\nErrorException: if supplied with kwargs having no corresponding AP .\n\nFunction initparser is exported.\n\nExamples\n\njulia> initparser(InteractiveArgumentParser; description=\"blablabla\", color=\"magenta\", add_help=true, throw_on_exception=true)\nInteractiveArgumentParser(ArgumentParser(OrderedCollections.OrderedDict{UInt16, ArgumentValues}(), OrderedCollections.OrderedDict{String, UInt16}(), 0x0000, \"blablabla\", \"\", \"\", String[], true, \"magenta\"), true, \"\", \"> \")\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#YAArguParser.sort_args-Tuple{Any}","page":"Docstrings","title":"YAArguParser.sort_args","text":"sort_args(parser::AbstractArgumentParser) → (;pos_args, keyed_args, all_args)\n\nFunction sort_args is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.update_val!-Tuple{Any, Any, Any}","page":"Docstrings","title":"YAArguParser.update_val!","text":"update_val!(parser::AbstractArgumentParser, numkey::Integer, val_str::AbstractString) → ::Union{Nothing, Exception}\n\nSee also set_value!. Function update_val! is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#YAArguParser.warn_and_return-Tuple{Any}","page":"Docstrings","title":"YAArguParser.warn_and_return","text":"warn_and_return(v) → (; ok=false, v=nothing)\n\nPrints a warning message and returns a tuple signalling invalid input. Used by the methods  of validate function.\n\nFunction validate is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Index","page":"Docstrings","title":"Index","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"}]
}
